<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Mock community evaluation</title>

<script src="site_libs/jquery-1.12.4/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<script src="site_libs/htmlwidgets-1.5.2/htmlwidgets.js"></script>
<link href="site_libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="site_libs/datatables-binding-0.16/datatables.js"></script>
<link href="site_libs/dt-core-1.10.20/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="site_libs/dt-core-1.10.20/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="site_libs/dt-core-1.10.20/js/jquery.dataTables.min.js"></script>
<link href="site_libs/crosstalk-1.1.0.1/css/crosstalk.css" rel="stylesheet" />
<script src="site_libs/crosstalk-1.1.0.1/js/crosstalk.min.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Comparing ITS1 and RPS10 for Oomycete Metabacoding</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="01--prepare_reference_database.html">Reference database preparation</a>
    </li>
    <li>
      <a href="02--preparation_and_quality_filtering.html">Read processing and quality filtering</a>
    </li>
    <li>
      <a href="03--abundance_matrix_preparation.html">Abundance matrix and taxonomic assignment</a>
    </li>
    <li>
      <a href="04--blast_classification.html">Alternative taxonomic assignment using BLAST</a>
    </li>
    <li>
      <a href="05--otu_clustering_threshold.html">OTU clustering threshold estimation</a>
    </li>
    <li>
      <a href="06--mock_community.html">Mock community evaluation</a>
    </li>
    <li>
      <a href="07--nontarget_amplification.html">Non-target amplification</a>
    </li>
    <li>
      <a href="08--amplicon_taxonomic_resolution.html">Taxonomic resolution</a>
    </li>
    <li>
      <a href="09--simulated_pcr_results.html">Plotting of simulated PCR results</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/grunwaldlab/rps10_barcode">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Mock community evaluation</h1>

</div>


<div id="prepare" class="section level2">
<h2>Prepare</h2>
<div id="packages-used" class="section level3">
<h3>Packages used</h3>
<pre class="r"><code>library(dplyr)
library(purrr)
library(furrr)
library(tidyr)
library(readr)
library(ggplot2)
library(sessioninfo)
library(metacoder)
library(vegan)
library(viridis)
library(taxize)
library(purrr)
library(ape)
library(ips)
library(insect)
library(phangorn)
library(DT)
library(gridExtra)
library(stringr)
library(Biostrings)</code></pre>
</div>
</div>
<div id="mock-community-reconstruction" class="section level2">
<h2>Mock community reconstruction</h2>
<p>The primary goal of any barcode is to accurately reconstruct community of organisms it is used on. We sequenced known mock communities to evaluate how well rps10 and ITS1 can infer these communities.</p>
<div id="parameters" class="section level3">
<h3>Parameters</h3>
<pre class="r"><code>minimum_read_count &lt;- 10
seed &lt;- 1
set.seed(seed)</code></pre>
<p>The minimum read count is higher than would be usual for a metabarcoding analysis. We chose a relatively high read count because this analysis will only use the mock community and since the mock community is less diverse than most natural communities that metabarcoding is used on, we expected erroneous sequences to be more common than usual.</p>
</div>
<div id="parallel-processing" class="section level3">
<h3>Parallel processing</h3>
<p>Commands that have “future” in them are run on multiple cores using the <code>furrr</code> and <code>future</code> packages.</p>
<pre class="r"><code>plan(multiprocess)</code></pre>
<pre><code>## Warning: [ONE-TIME WARNING] Forked processing (&#39;multicore&#39;) is disabled
## in future (&gt;= 1.13.0) when running R from RStudio, because it is
## considered unstable. Because of this, plan(&quot;multicore&quot;) will fall
## back to plan(&quot;sequential&quot;), and plan(&quot;multiprocess&quot;) will fall back to
## plan(&quot;multisession&quot;) - not plan(&quot;multicore&quot;) as in the past. For more details,
## how to control forked processing or not, and how to silence this warning in
## future R sessions, see ?future::supportsMulticore</code></pre>
</div>
<div id="read-abundance-matrix-and-sample-data" class="section level3">
<h3>Read abundance matrix and sample data</h3>
<p>Read the sample metadata table:</p>
<pre class="r"><code>metadata &lt;- read_csv(file.path(&#39;intermediate_data&#39;, &#39;metadata.csv&#39;))</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   sample_id = col_character(),
##   primer_pair_id = col_character(),
##   dna_type = col_character(),
##   dna_sample_id = col_character(),
##   locus = col_character(),
##   forward = col_character(),
##   reverse = col_character(),
##   sample_type = col_character()
## )</code></pre>
<pre class="r"><code>datatable(metadata)</code></pre>
<div id="htmlwidget-2a0dd1ba32e0541469b5" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-2a0dd1ba32e0541469b5">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48"],["A1","A2","A3","A4","A5","A6","B1","B2","B3","B4","B5","B6","C1","C2","C3","C4","C5","C6","D1","D2","D3","D4","D5","D6","E1","E2","E3","E4","E5","E6","F1","F2","F3","F4","F5","F6","G1","G2","G3","G4","G5","G6","H1","H2","H3","H4","H5","H6"],["rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7","rps10_Final","rps10_Final","rps10_Felipe","rps10_Felipe","ITS6/7","ITS6/7"],["mock1","leaf","mock1","leaf","mock1","leaf","mock2","WR.soil","mock2","WR.soil","mock2","WR.soil","ag.soil","WR.soil","ag.soil","WR.soil","ag.soil","WR.soil","drip","WR.soil","drip","WR.soil","drip","WR.soil","drip","Pan.soil","drip","Pan.soil","drip","Pan.soil","drip","Pan.soil","drip","Pan.soil","drip","Pan.soil","leaf","Pan.soil","leaf","Pan.soil","leaf","Pan.soil","leaf","control","leaf","control","leaf","control"],["mock1","L95","mock1","L95","mock1","L95","mock2","WS3","mock2","WS3","mock2","WS3","AG1","WS7","AG1","WS7","AG1","WS7","D3","WS23","D3","WS23","D3","WS23","D4","PS1","D4","PS1","D4","PS1","D19","PS2","D19","PS2","D19","PS2","L47","PS3","L47","PS3","L47","PS3","L90","control","L90","control","L90","control"],["rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS","rps10","rps10","rps10","rps10","ITS","ITS"],["rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6","rps10-F","rps10-F","rps10_f-F","rps10_f-F","ITS6","ITS6"],["rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7","rps10-R","rps10-R","rps10-R","rps10-R","ITS7","ITS7"],["Mock community","Sample","Mock community","Sample","Mock community","Sample","Mock community","Sample","Mock community","Sample","Mock community","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Sample","Negative control","Sample","Negative control","Sample","Negative control"]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>sample_id<\/th>\n      <th>primer_pair_id<\/th>\n      <th>dna_type<\/th>\n      <th>dna_sample_id<\/th>\n      <th>locus<\/th>\n      <th>forward<\/th>\n      <th>reverse<\/th>\n      <th>sample_type<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"order":[],"autoWidth":false,"orderClasses":false,"columnDefs":[{"orderable":false,"targets":0}]}},"evals":[],"jsHooks":[]}</script>
<p>Read the ASV abundance matrix:</p>
<pre class="r"><code>read_abund_mat &lt;- function(path) {
  # Read CSV
  abundance &lt;- read_csv(path)
  
  # Clean up species names
  abundance$taxonomy &lt;- abundance$taxonomy %&gt;%
    sub(pattern = &#39; aff. &#39;, replacement = &#39;&#39;, fixed = TRUE)
  
  asv_data &lt;- parse_tax_data(abundance, class_cols = &#39;taxonomy&#39;, class_sep = &#39;;&#39;,
                             class_regex = &#39;^(.+)--(.+)--(.+)$&#39;,
                             class_key = c(taxon = &#39;taxon_name&#39;, boot = &#39;info&#39;, rank = &#39;taxon_rank&#39;))
  names(asv_data$data) &lt;- c(&#39;abund&#39;, &#39;score&#39;)
  transmute_obs(asv_data, &#39;score&#39;, sequence = sequence[input_index], boot = boot, rank = rank)
}

asv_data &lt;- read_abund_mat(file.path(&#39;intermediate_data&#39;, &#39;abundance_asv.csv&#39;))</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   .default = col_double(),
##   sequence = col_character(),
##   blast_tax = col_character(),
##   taxonomy = col_character()
## )
## ℹ Use `spec()` for the full column specifications.</code></pre>
<pre><code>## Warning: `as.tbl()` is deprecated as of dplyr 1.0.0.
## Please use `tibble::as_tibble()` instead.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_warnings()` to see where this warning was generated.</code></pre>
<pre class="r"><code>otu_data &lt;- read_abund_mat(file.path(&#39;intermediate_data&#39;, &#39;abundance_otu.csv&#39;))</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   .default = col_double(),
##   sequence = col_character(),
##   blast_tax = col_character(),
##   taxonomy = col_character()
## )
## ℹ Use `spec()` for the full column specifications.</code></pre>
</div>
<div id="subset-data-to-just-mock-community" class="section level3">
<h3>Subset data to just mock community</h3>
<p>Only <code>mock2</code> will be used in the paper. <code>mock1</code> was another, older mock community. I will also zero out low abundance ASVs, since that would be done in a normal metabarcoding analysis. And convert to proportions in case that is needed later.</p>
<pre class="r"><code>its_mock_sample &lt;- metadata$sample_id[metadata$dna_type == &#39;mock2&#39; &amp; metadata$primer_pair_id == &#39;ITS6/7&#39;]
rps_mock_sample &lt;- metadata$sample_id[metadata$dna_type == &#39;mock2&#39; &amp; metadata$primer_pair_id == &#39;rps10_Final&#39;]
mock_samples &lt;- c(rps_mock_sample, its_mock_sample)

prep_mock_samples &lt;- function(obj) {
  # just mock samples
  obj &lt;- select_obs(obj, data = &#39;abund&#39;, sequence, taxonomy, !!! mock_samples)
  obj &lt;- filter_obs(obj, data = &#39;abund&#39;, rowSums(obj$data$abund[mock_samples]) &gt; 0, drop_taxa = TRUE)
  obj &lt;- filter_obs(obj, data = &#39;score&#39;, obj$data$score$sequence %in% obj$data$abund$sequence, drop_taxa = TRUE)
  # zero out low abundance
  obj$data$abund &lt;- zero_low_counts(obj, &#39;abund&#39;, min_count = minimum_read_count, other_cols = TRUE)
  obj &lt;- filter_obs(obj, &#39;abund&#39;, rowSums(obj$data$abund[, mock_samples]) &gt; 0, drop_taxa = TRUE)
  obj &lt;- filter_obs(obj, &#39;score&#39;, obj$data$score$sequence %in% obj$data$abund$sequence, drop_taxa = TRUE)
  # convert to proportions
  obj$data$prop &lt;- calc_obs_props(obj, &#39;abund&#39;)
  obj
}

asv_data &lt;- prep_mock_samples(asv_data)</code></pre>
<pre><code>## No `cols` specified, so using all numeric columns:
##    B1, B5</code></pre>
<pre><code>## Zeroing 37 of 244 counts less than 10.</code></pre>
<pre><code>## Warning: The following columns will be replaced in the output:
##    B1, B5</code></pre>
<pre><code>## No `cols` specified, so using all numeric columns:
##    B1, B5</code></pre>
<pre><code>## Calculating proportions from counts for 2 columns for 85 observations.</code></pre>
<pre class="r"><code>otu_data &lt;- prep_mock_samples(otu_data)</code></pre>
<pre><code>## No `cols` specified, so using all numeric columns:
##    B1, B5</code></pre>
<pre><code>## Zeroing 88 of 328 counts less than 10.</code></pre>
<pre><code>## Warning: The following columns will be replaced in the output:
##    B1, B5</code></pre>
<pre><code>## No `cols` specified, so using all numeric columns:
##    B1, B5</code></pre>
<pre><code>## Calculating proportions from counts for 2 columns for 76 observations.</code></pre>
<pre class="r"><code>print(asv_data)</code></pre>
<pre><code>## &lt;Taxmap&gt;
##   210 taxa: aab. Eukaryota ... mep. CTTCCGTAGGTGAC[truncated]
##   210 edges: NA-&gt;aab, aab-&gt;aac, aab-&gt;aad ... ebf-&gt;lxl, efv-&gt;mep
##   3 data sets:
##     abund:
##       # A tibble: 85 x 5
##         taxon_id sequence             taxonomy               B1     B5
##         &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;               &lt;dbl&gt;  &lt;dbl&gt;
##       1 gqf      GAAAATCTTTGTGTCGGCG… Eukaryota--100--Do…    18      0
##       2 gqk      TTTCCGTAGGTGAACCTGC… Eukaryota--100--Do…     0 147595
##       3 gqt      GAAAATCTTTGTGTCGGTG… Eukaryota--100--Do… 45398      0
##       # … with 82 more rows
##     score:
##       # A tibble: 850 x 4
##         taxon_id sequence                                 boot  rank  
##         &lt;chr&gt;    &lt;chr&gt;                                    &lt;chr&gt; &lt;chr&gt; 
##       1 aab      GAAAATCTTTGTGTCGGCGGTTCAAGTCCGTCTCTAAAC… 100   Domai…
##       2 aac      GAAAATCTTTGTGTCGGCGGTTCAAGTCCGTCTCTAAAC… 100   Kingd…
##       3 aak      GAAAATCTTTGTGTCGGCGGTTCAAGTCCGTCTCTAAAC… 100   Phylum
##       # … with 847 more rows
##     prop:
##       # A tibble: 85 x 3
##         taxon_id        B1    B5
##         &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;
##       1 gqf      0.0000742 0    
##       2 gqk      0         0.399
##       3 gqt      0.187     0    
##       # … with 82 more rows
##   0 functions:</code></pre>
<pre class="r"><code>print(otu_data)</code></pre>
<pre><code>## &lt;Taxmap&gt;
##   193 taxa: aab. Eukaryota ... leq. TTTCCGTAGGTGAA[truncated]
##   193 edges: NA-&gt;aab, aab-&gt;aac, aab-&gt;aad ... dxl-&gt;lee, dxl-&gt;leq
##   3 data sets:
##     abund:
##       # A tibble: 76 x 5
##         taxon_id sequence             taxonomy               B1     B5
##         &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;               &lt;dbl&gt;  &lt;dbl&gt;
##       1 gmm      TTTCCGTAGGTGAACCTGC… Eukaryota--100--Do…     0 147595
##       2 gmt      TTTCCGTAGGTGAACCTGC… Eukaryota--100--Do…     0     40
##       3 gmv      TTTCCGTAGGTGAACCTGC… Eukaryota--100--Do…     0  60788
##       # … with 73 more rows
##     score:
##       # A tibble: 760 x 4
##         taxon_id sequence                                 boot  rank  
##         &lt;chr&gt;    &lt;chr&gt;                                    &lt;chr&gt; &lt;chr&gt; 
##       1 aab      TTTCCGTAGGTGAACCTGCGGAAGGATCATTACCACACC… 100   Domai…
##       2 aac      TTTCCGTAGGTGAACCTGCGGAAGGATCATTACCACACC… 100   Kingd…
##       3 aak      TTTCCGTAGGTGAACCTGCGGAAGGATCATTACCACACC… 100   Phylum
##       # … with 757 more rows
##     prop:
##       # A tibble: 76 x 3
##         taxon_id    B1       B5
##         &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;
##       1 gmm          0 0.411   
##       2 gmt          0 0.000111
##       3 gmv          0 0.169   
##       # … with 73 more rows
##   0 functions:</code></pre>
<p>Since there is only two samples and each ASV is only found in one:</p>
<pre class="r"><code>stopifnot(all(rowSums(asv_data$data$abund[4:5] == 0) == 1))
stopifnot(all(rowSums(otu_data$data$abund[4:5] == 0) == 1))</code></pre>
<p>I can reformat the abundance matrix like so:</p>
<pre class="r"><code>reformat_abund_mat &lt;- function(obj) {
  obj$data$abund &lt;- transmute(obj$data$abund, taxon_id, sequence, taxonomy,
                              asv_count = rowSums(obj$data$abund[mock_samples]),
                              locus = ifelse(obj$data$abund[[its_mock_sample]] &gt; 0, &#39;ITS&#39;, &#39;rps10&#39;))
  obj$data$prop &lt;- transmute(obj$data$prop, taxon_id, 
                             asv_count = rowSums(obj$data$prop[mock_samples]),
                             locus = ifelse(obj$data$prop[[its_mock_sample]] &gt; 0, &#39;ITS&#39;, &#39;rps10&#39;))
  obj
}

asv_data &lt;- reformat_abund_mat(asv_data)
otu_data &lt;- reformat_abund_mat(otu_data)</code></pre>
<p>and I can add which reference sequence each asv was assigned to and its PID as seperate columns for easy use afterwards.</p>
<pre class="r"><code>add_assigned_ref_seq &lt;- function(obj) {
  
  # Add name of reference sequence
  obj$data$abund$reference &lt;- str_match(obj$data$abund$taxonomy, &#39;.+;(.+)--[0-9]+--Reference;.+$&#39;)[,2]
  obj$data$abund$reference &lt;- gsub(obj$data$abund$reference, pattern = &#39;_&#39;, replacement = &#39; &#39;)
  
  # Add PID match to reference sequence as a column
  obj$data$abund$ref_pid &lt;- str_match(obj$data$abund$taxonomy, &#39;.+;.+--[0-9]+--Reference;.+--([0-9.]+)--ASV$&#39;)[,2]
  
  obj
}

asv_data &lt;- add_assigned_ref_seq(asv_data)
otu_data &lt;- add_assigned_ref_seq(otu_data)</code></pre>
</div>
<div id="evaluating-mock-community-reconstruction-taxonomic-assignments" class="section level3">
<h3>Evaluating mock community reconstruction: taxonomic assignments</h3>
<p>I will consider how the well the mock community was characterized by each method in the context of the taxonomic assignments of the ASVs by dada2. The following metrics will be calculated:</p>
<ul>
<li>The number of expected mock community identified</li>
<li>The proportion of ASVs assigned to an expected member of the mock community</li>
<li>The proportion of reads assigned to an expected member of the mock community</li>
</ul>
<p>Note that all the mock community members have sequences in the reference databases:</p>
<pre class="r"><code>mc_data &lt;- read_csv(file.path(&#39;intermediate_data&#39;, &#39;mock_community.csv&#39;))</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   species = col_character(),
##   concentration = col_double(),
##   isolate = col_character(),
##   growth_medium = col_character(),
##   extraction_kit = col_character(),
##   in_its_db = col_logical(),
##   in_rps10_db = col_logical(),
##   in_its_db_no_ambig = col_logical(),
##   in_rps10_db_no_ambig = col_logical()
## )</code></pre>
<pre class="r"><code>mc_syn_data &lt;- read_csv(file.path(&#39;raw_data&#39;, &#39;mock_comm_synonyms.csv&#39;))</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   mc_name = col_character(),
##   col_id = col_character(),
##   syn_name = col_character(),
##   rank = col_character(),
##   name_status = col_character(),
##   genus = col_character(),
##   subgenus = col_logical(),
##   species = col_character(),
##   infraspecies_marker = col_character(),
##   infraspecies = col_character(),
##   author = col_character(),
##   record_scrutiny_date = col_logical(),
##   online_resource = col_logical(),
##   is_extinct = col_double(),
##   name_html = col_character(),
##   url = col_character()
## )</code></pre>
<pre class="r"><code>mc_data$in_both_db &lt;- mc_data$in_rps10_db &amp; mc_data$in_its_db
stopifnot(all(mc_data$in_both_db))</code></pre>
<p>To make the data easier to use, I will add the list of synonyms and the name used in the mock community to a column in the mock community data. Note that this column is a list of character vectors.</p>
<pre class="r"><code>mc_data$all_names &lt;- lapply(mc_data$species, function(sp_name) {
  sp_name &lt;- gsub(sp_name, pattern = &#39;_&#39;, replacement = &#39; &#39;, fixed = TRUE)
  unique(c(sp_name, mc_syn_data$syn_name[tolower(mc_syn_data$mc_name) == tolower(sp_name)]))
})</code></pre>
<p>I will also figure out which reference sequences might represent members of the mock community and the names of species in the mock community they correspond to.</p>
<pre class="r"><code>make_ref_data &lt;- function(ref_path, ranks) {
  
  # make table from fasta info
  ref_seqs &lt;- read_fasta(file.path(&#39;intermediate_data&#39;, &#39;reference_databases&#39;, ref_path))
  ref_data &lt;- tibble(header = sub(names(ref_seqs), pattern = &#39;;$&#39;, replacement = &#39;&#39;), 
                     sequence = ref_seqs)
  ref_data$header &lt;- gsub(ref_data$header, pattern = &#39;_&#39;, replacement = &#39; &#39;)
  ref_data &lt;- separate(ref_data, header, into = ranks, sep = &#39;;&#39;)
  
  # Identify sequences that should be in the mock community
  ref_data &lt;- mutate(
    ref_data,
    expected_in_mc = tolower(species) %in% tolower(unlist(mc_data$all_names)),
  )
  ref_data$names_in_mc &lt;- map(ref_data$species, function(ref_sp) {
    matches_mc &lt;- map_lgl(mc_data$all_names, function(mc_sp_names) {
      ref_sp %in% mc_sp_names
    })
    mc_data$species[matches_mc]
  })
  
  # Clean up species names
  ref_data$species &lt;- ref_data$species %&gt;%
    sub(pattern = &#39; subsp\\..*&#39;, replacement = &#39;&#39;) %&gt;%
    sub(pattern = &#39; var\\..*&#39;, replacement = &#39;&#39;) %&gt;%
    sub(pattern = &#39; cf\\.&#39;, replacement = &#39;&#39;) %&gt;%
    sub(pattern = &#39; aff\\.&#39;, replacement = &#39;&#39;)
  
  ref_data
}

its_ref_data &lt;- make_ref_data(&#39;its1_reference_db.fa&#39;,
                              c(&quot;domaine&quot;, &quot;kingdom&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;, &quot;reference&quot;))
rps10_ref_data &lt;- make_ref_data(&#39;rps10_reference_db.fa&#39;,
                                c(&quot;domaine&quot;, &quot;kingdom&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;, &quot;reference&quot;))</code></pre>
<p>Lets see which species in the reference database that were considered to be members of the mock community based on the synonym to make sure the synonyms are reasonable:</p>
<pre class="r"><code>print_ambiguous_mc_matches &lt;- function(data) {
  to_look_at &lt;- map_lgl(1:nrow(data), function(i) data$expected_in_mc[i] &amp;&amp; (length(data$names_in_mc[[i]]) &gt; 1 | data$species[i] != data$names_in_mc[[i]][1]))
  info &lt;- map(which(to_look_at), function(i) paste0(&#39;Ref species name: &#39;, data$species[i], &#39;\nMatching mock comm names: &#39;, paste(data$names_in_mc[[i]], collapse = &#39;, &#39;), &#39;\n\n&#39;))
  for (x in unique(info)) {
    cat(x)
  }
}
print_ambiguous_mc_matches(its_ref_data)</code></pre>
<pre><code>## Ref species name: Peronospora chenopodii-polyspermi
## Matching mock comm names: Peronospora effusa, Peronospora schachtii
## 
## Ref species name: Ovatisporangium citrinum
## Matching mock comm names: Phytopythium citrinum
## 
## Ref species name: Peronospora effusa
## Matching mock comm names: Peronospora effusa, Peronospora schachtii
## 
## Ref species name: Peronospora schachtii
## Matching mock comm names: Peronospora effusa, Peronospora schachtii</code></pre>
<pre class="r"><code>print_ambiguous_mc_matches(rps10_ref_data)</code></pre>
<pre><code>## Ref species name: Peronospora effusa
## Matching mock comm names: Peronospora effusa, Peronospora schachtii
## 
## Ref species name: Peronospora atriplicis-hastatae
## Matching mock comm names: Peronospora effusa, Peronospora schachtii
## 
## Ref species name: Peronospora litoralis
## Matching mock comm names: Peronospora effusa, Peronospora schachtii
## 
## Ref species name: Peronospora schachtii
## Matching mock comm names: Peronospora effusa, Peronospora schachtii
## 
## Ref species name: Pseudoperonospora humuli
## Matching mock comm names: Pseudoperonospora cubensis
## 
## Ref species name: Pythium citrinum
## Matching mock comm names: Phytopythium citrinum</code></pre>
<p>Lets get the number of OTUs and ASVs in the mock community for each locus. I will put the results in a table of info for each locus that I will populate with additional columns throughout the analysis.</p>
<pre class="r"><code>locus_result_table &lt;- tibble(locus = c(&#39;rps10&#39;, &#39;ITS&#39;),
                             n_asv = table(asv_data$data$abund$locus)[locus],
                             n_otu = table(otu_data$data$abund$locus)[locus])
locus_result_table</code></pre>
<pre><code>## # A tibble: 2 x 3
##   locus n_asv   n_otu  
##   &lt;chr&gt; &lt;table&gt; &lt;table&gt;
## 1 rps10 40      46     
## 2 ITS   45      30</code></pre>
<div id="the-number-of-expected-mock-community-species-identified" class="section level4">
<h4>The number of expected mock community species identified</h4>
<p>I will first find which mock community members where found in the taxonomic classifications of the ASVs</p>
<pre class="r"><code>find_mock_in_tax &lt;- function(obj, my_locus, ref_data) {
  # Get data for the locus and combine with reference data 
  names(ref_data)[colnames(ref_data) == &#39;sequence&#39;] &lt;- &#39;ref_sequence&#39;
  locus_data &lt;- filter(obj$data$abund, locus == my_locus) %&gt;%
    left_join(ref_data, by = &quot;reference&quot;)
  
  # Check which mock community members were found
  mc_tax_found &lt;- map_lgl(mc_data$all_names, function(mc_synonyms) {
    any(mc_synonyms %in% locus_data$species)
  })
  
  names(mc_tax_found) &lt;- mc_data$species
  mc_tax_found
}</code></pre>
<p>For <strong>rps10</strong>:</p>
<pre class="r"><code>find_mock_in_tax(asv_data, &#39;rps10&#39;, rps10_ref_data)</code></pre>
<pre><code>##      Aphanomyces euteiches         Peronospora effusa 
##                       TRUE                       TRUE 
##      Peronospora schachtii      Phytopythium citrinum 
##                       TRUE                       TRUE 
##     Phytophthora cinnamomi  Phytophthora citrophthora 
##                       TRUE                       TRUE 
##    Phytophthora himalsilva     Phytophthora hydrogena 
##                       TRUE                       TRUE 
##     Phytophthora infestans      Phytophthora ipomoeae 
##                       TRUE                      FALSE 
##     Phytophthora kernoviae     Phytophthora pluvialis 
##                       TRUE                       TRUE 
##      Phytophthora quercina       Phytophthora ramorum 
##                       TRUE                       TRUE 
##    Phytophthora rosacearum       Plasmopara halstedii 
##                       TRUE                       TRUE 
##        Plasmopara obducens Pseudoperonospora cubensis 
##                       TRUE                       TRUE 
##         Pythium apiculatum         Pythium dissotocum 
##                       TRUE                       TRUE 
##         Pythium irregulare         Pythium oligandrum 
##                       TRUE                       TRUE 
##          Pythium undulatum        Saprolegnia diclina 
##                       TRUE                       TRUE</code></pre>
<p>For <strong>ITS1</strong>:</p>
<pre class="r"><code>find_mock_in_tax(asv_data, &#39;ITS&#39;, its_ref_data)</code></pre>
<pre><code>##      Aphanomyces euteiches         Peronospora effusa 
##                       TRUE                       TRUE 
##      Peronospora schachtii      Phytopythium citrinum 
##                       TRUE                       TRUE 
##     Phytophthora cinnamomi  Phytophthora citrophthora 
##                       TRUE                      FALSE 
##    Phytophthora himalsilva     Phytophthora hydrogena 
##                      FALSE                       TRUE 
##     Phytophthora infestans      Phytophthora ipomoeae 
##                       TRUE                      FALSE 
##     Phytophthora kernoviae     Phytophthora pluvialis 
##                       TRUE                       TRUE 
##      Phytophthora quercina       Phytophthora ramorum 
##                      FALSE                       TRUE 
##    Phytophthora rosacearum       Plasmopara halstedii 
##                       TRUE                       TRUE 
##        Plasmopara obducens Pseudoperonospora cubensis 
##                       TRUE                       TRUE 
##         Pythium apiculatum         Pythium dissotocum 
##                       TRUE                      FALSE 
##         Pythium irregulare         Pythium oligandrum 
##                       TRUE                      FALSE 
##          Pythium undulatum        Saprolegnia diclina 
##                      FALSE                       TRUE</code></pre>
<p>I will add that the number of mock community species found to the table:</p>
<pre class="r"><code>locus_result_table$n_mc_in_tax &lt;- c(sum(find_mock_in_tax(asv_data, &#39;rps10&#39;, rps10_ref_data)),
                                    sum(find_mock_in_tax(asv_data, &#39;ITS&#39;, its_ref_data)))</code></pre>
</div>
<div id="the-proportion-of-the-asvs-and-reads-assigned-to-members-of-the-mock-community" class="section level4">
<h4>The proportion of the ASVs and reads assigned to members of the mock community</h4>
<p>It would also be useful to know what proportion of the ASVs were assigned to members of the mock community:</p>
<pre class="r"><code>tax_in_mock &lt;- function(obj, my_locus, ref_data) {
  # Get data for the locus and combine with reference data 
  names(ref_data)[colnames(ref_data) == &#39;sequence&#39;] &lt;- &#39;ref_sequence&#39;
  locus_data &lt;- filter(obj$data$abund, locus == my_locus) %&gt;%
    left_join(ref_data, by = &quot;reference&quot;)
  
  # Check which mock community members were found
  locus_data$is_mock &lt;- locus_data$species %in% unique(unlist(mc_data$all_names))
  
  # Format result
  locus_data %&gt;%
    select(species, reference, asv_count, is_mock) %&gt;%
    arrange(desc(asv_count))
}</code></pre>
<p>For <strong>rps10</strong>:</p>
<pre class="r"><code>rps10_tax_in_mock &lt;- tax_in_mock(asv_data, &#39;rps10&#39;, rps10_ref_data)
as.data.frame(rps10_tax_in_mock)</code></pre>
<pre><code>##                       species reference asv_count is_mock
## 1          Pythium apiculatum  oodb 633     45398    TRUE
## 2   Phytophthora citrophthora  oodb 271     28991    TRUE
## 3      Phytophthora kernoviae  oodb 407     22616    TRUE
## 4       Phytophthora quercina  oodb 526     22213    TRUE
## 5      Phytophthora hydrogena  oodb 337     21235    TRUE
## 6        Phytophthora ramorum  oodb 605     16742    TRUE
## 7   Phytophthora citrophthora  oodb 271     12259    TRUE
## 8         Saprolegnia diclina  oodb 731     10641    TRUE
## 9       Phytopythium citrinum  oodb 611     10283    TRUE
## 10        Plasmopara obducens  oodb 619      9428    TRUE
## 11     Phytophthora infestans  oodb 384      8080    TRUE
## 12     Phytophthora pluvialis  oodb 510      6415    TRUE
## 13     Phytophthora cinnamomi  oodb 268      4745    TRUE
## 14         Pythium irregulare  oodb 660      3967    TRUE
## 15         Pythium oligandrum  oodb 678      3636    TRUE
## 16    Phytophthora himalsilva  oodb 333      3605    TRUE
## 17    Phytophthora rosacearum  oodb 547      2830    TRUE
## 18      Aphanomyces euteiches   oodb 11      2572    TRUE
## 19    Phytophthora himalsilva  oodb 333      1838    TRUE
## 20         Pythium dissotocum  oodb 802       938    TRUE
## 21         Peronospora effusa   oodb 42       902    TRUE
## 22      Aphanomyces euteiches    oodb 9       872    TRUE
## 23         Pythium apiculatum  oodb 773       516    TRUE
## 24         Pythium apiculatum  oodb 773       478    TRUE
## 25     Phytophthora kernoviae  oodb 598       351    TRUE
## 26 Pseudoperonospora cubensis  oodb 624       330    TRUE
## 27          Pythium undulatum  oodb 882       128    TRUE
## 28     Phytophthora hydrogena  oodb 337       121    TRUE
## 29       Plasmopara halstedii  oodb 618        90    TRUE
## 30        Plasmopara obducens  oodb 619        83    TRUE
## 31         Pythium apiculatum  oodb 773        45    TRUE
## 32     Phytophthora kernoviae  oodb 407        43    TRUE
## 33        Plasmopara obducens  oodb 619        31    TRUE
## 34      Phytophthora quercina  oodb 526        29    TRUE
## 35         Pythium dissotocum  oodb 802        24    TRUE
## 36     Phytophthora pluvialis  oodb 510        21    TRUE
## 37         Pythium dissotocum  oodb 802        20    TRUE
## 38           Pythium periilum  oodb 848        19   FALSE
## 39            Achlya hypogyna    oodb 1        18   FALSE
## 40     Phytophthora pluvialis  oodb 510        12    TRUE</code></pre>
<p>For <strong>ITS1</strong>:</p>
<pre class="r"><code>its_tax_in_mock &lt;- tax_in_mock(asv_data, &#39;ITS&#39;, its_ref_data)
as.data.frame(its_tax_in_mock)</code></pre>
<pre><code>##                       species          reference asv_count is_mock
## 1     Phytophthora colocasiae  phytodb 121 54018    147595   FALSE
## 2        Phytophthora ramorum  phytodb 253 54150     60788    TRUE
## 3      Phytophthora hydrogena       mock 7 54244     47346    TRUE
## 4       Phytopythium citrinum      mock 15 54252     30404    TRUE
## 5      Phytophthora cinnamomi  phytodb 223 54120     25411    TRUE
## 6        Phytophthora capsici  unite 46812 38400     12611   FALSE
## 7      Phytophthora kernoviae  rob2011 298 52993      9264    TRUE
## 8         Saprolegnia diclina      mock 23 54260      4206    TRUE
## 9      Phytophthora hydrogena       mock 7 54244      3438    TRUE
## 10         Pythium apiculatum  rob2011 630 53325      3192    TRUE
## 11     Phytophthora infestans  unite 39990 32413      2892    TRUE
## 12    Phytophthora rosacearum  rob2011 439 53134      2550    TRUE
## 13        Pythium amasculinum  rob2011 621 53316      2438   FALSE
## 14          Pythium coloratum  rob2011 687 53382      2143   FALSE
## 15         Pythium senticosum  rob2011 948 53643      1929   FALSE
## 16     Phytophthora hydrogena       mock 7 54244      1626    TRUE
## 17     Phytophthora pluvialis      mock 11 54248      1289    TRUE
## 18         Pythium irregulare  rob2011 811 53506      1174    TRUE
## 19         Pythium irregulare  rob2011 852 53547      1089    TRUE
## 20        Plasmopara obducens  unite 31977 26019      1016    TRUE
## 21         Pythium apiculatum  rob2011 630 53325      1005    TRUE
## 22 Elongisporangium undulatum rob2011 1135 53830       836   FALSE
## 23      Aphanomyces euteiches    unite 3163 2348       525    TRUE
## 24    Phytophthora rosacearum  rob2011 439 53134       495    TRUE
## 25         Pythium irregulare  rob2011 853 53548       464    TRUE
## 26         Pythium irregulare  rob2011 853 53548       451    TRUE
## 27     Phytophthora hydrogena       mock 7 54244       448    TRUE
## 28    Phytophthora colocasiae  phytodb 121 54018       394   FALSE
## 29         Peronospora effusa       mock 2 54239       351    TRUE
## 30         Pythium irregulare  rob2011 811 53506       325    TRUE
## 31        Plasmopara obducens  unite 31977 26019       317    TRUE
## 32         Pythium apiculatum  rob2011 630 53325       295    TRUE
## 33     Phytophthora infestans  unite 39990 32413       295    TRUE
## 34    Phytophthora rosacearum  rob2011 439 53134       170    TRUE
## 35    Phytophthora colocasiae  phytodb 121 54018       135   FALSE
## 36     Phytophthora hydrogena       mock 7 54244       122    TRUE
## 37         Pythium apiculatum  rob2011 630 53325       115    TRUE
## 38       Plasmopara halstedii  unite 31976 26018       114    TRUE
## 39     Phytophthora hydrogena       mock 7 54244        84    TRUE
## 40         Pythium irregulare  rob2011 811 53506        62    TRUE
## 41 Pseudoperonospora cubensis  rob2011 584 53279        58    TRUE
## 42     Haglerozyma chiarellii    unite 9409 7272        40   FALSE
## 43    Phytopythium carbonicum  rob2011 537 53232        13   FALSE
## 44      Ramaria claviramulata  unite 22934 18384        10   FALSE
## 45        Plasmopara obducens  unite 31977 26019        10    TRUE</code></pre>
<p>I will add that the proportion of species found that are in the mock community to the table:</p>
<pre class="r"><code>locus_result_table$prop_asv_in_mc_tax &lt;- c(sum(rps10_tax_in_mock$is_mock) / nrow(rps10_tax_in_mock), 
                                           sum(its_tax_in_mock$is_mock) / nrow(its_tax_in_mock))</code></pre>
<p>and the proportion of reads represented by those sequences</p>
<pre class="r"><code>prop_reads_in_mc &lt;- function(aligned_data) {
  sum(aligned_data$asv_count[aligned_data$is_mock]) / sum(aligned_data$asv_count)
}

locus_result_table$prop_reads_in_mc_tax &lt;- c(prop_reads_in_mc(rps10_tax_in_mock), 
                                             prop_reads_in_mc(its_tax_in_mock))</code></pre>
</div>
</div>
<div id="evaluating-mock-community-reconstruction-sequences" class="section level3">
<h3>Evaluating mock community reconstruction: sequences</h3>
<p>Similar to the statistics generated above, I will summarize how well the mock community was reconstructed in the context of sequences found, ignoring taxonomic classifications. Specifically, I will calculate:</p>
<ul>
<li>The number of expected mock community sequences present in the ASVs<br />
</li>
<li>The number of expected mock community sequences present in the ASVs, allowing for 1bp mismatch</li>
<li>The proportion of ASVs matching the sequences of an expected member of the mock community</li>
<li>The proportion of reads matching the sequences of an expected member of the mock community</li>
</ul>
<div id="the-number-of-expected-mock-community-sequences-present-in-the-asvs" class="section level4">
<h4>The number of expected mock community sequences present in the ASVs</h4>
<p>First, I will also count how many of the mock community species have sequences represented by at least one ASV</p>
<pre class="r"><code># Check if bases match, allowing for IUPAC codes in reference
iupac_match &lt;- function(asv_chars, ref_chars) {
  map2_lgl(asv_chars, ref_chars, function(asv, ref) grepl(asv, pattern = paste0(&#39;[&#39;, IUPAC_CODE_MAP[ref], &#39;]+&#39;)))
}

# Count number of mismatches in an alignment, allowing for IUPAC codes in reference
align_mismatch &lt;- function(alignment) {
  asv_chars &lt;- strsplit(as.character(alignment@pattern), &#39;&#39;)[[1]]
  ref_chars &lt;- strsplit(as.character(alignment@subject), &#39;&#39;)[[1]]
  sum(! iupac_match(asv_chars, ref_chars))
}

align_mock_comm_seqs &lt;- function(obj, my_locus, ref_data) {
  # Get data for the locus and combine with reference data 
  names(ref_data)[colnames(ref_data) == &#39;sequence&#39;] &lt;- &#39;ref_sequence&#39;
  locus_data &lt;- filter(obj$data$abund, locus == my_locus) %&gt;%
    left_join(ref_data, by = &quot;reference&quot;)
  
  # Get sequences that should be in the mock community and make formatting consistent
  if (my_locus == &quot;rps10&quot;) {
    mock_seqs &lt;- read_fasta(file.path(&#39;raw_data&#39;, &#39;reference_databases&#39;, &#39;mock_comm_rps10_sanger.fasta&#39;))
    names(mock_seqs) &lt;- trimws(names(mock_seqs))
    names(mock_seqs) &lt;- gsub(names(mock_seqs), pattern = &#39;_&#39;, replacement = &#39; &#39;)
    names(mock_seqs) &lt;- str_match(names(mock_seqs), pattern = &#39;^.+;(.+)$&#39;)[, 2]
    # The Pythium undulatum sequence is not complete, so I will replace it with one from a reference database
    undulatum_ref_seqs &lt;- ref_data$ref_sequence[ref_data$species == &#39;Pythium undulatum&#39;]
    mock_seqs[&#39;Pythium undulatum&#39;] &lt;- undulatum_ref_seqs[which.max(nchar(undulatum_ref_seqs))]
  } else if (my_locus == &quot;ITS&quot;) {
    mock_seqs &lt;- read_fasta(file.path(&#39;raw_data&#39;, &#39;reference_databases&#39;, &#39;mock_comm_its1_sanger.fasta&#39;))
    names(mock_seqs) &lt;- str_match(names(mock_seqs), pattern = &#39;^(.+) .+$&#39;)[, 2]
    names(mock_seqs) &lt;- str_match(names(mock_seqs), pattern = &#39;^([a-zA-Z]+ [a-zA-Z]+).*$&#39;)[, 2]
    # Plasmopara halstedii was not sequenced successfully, so I will use a reference sequence
    mock_seqs &lt;- c(mock_seqs, setNames(its_ref_data$sequence[its_ref_data$species == &quot;Plasmopara halstedii&quot;], &quot;Plasmopara halstedii&quot;))
  } else {
    stop(&#39;Wrong locus type&#39;)
  }
  mock_seqs &lt;- trimws(mock_seqs)

  # Align each mock community sequence and applicable reference sequences to all ASVs and return best hit
  aligned_data &lt;-  lapply(seq_along(mock_seqs), function(i) {
    aligned &lt;- lapply(locus_data$sequence, function(asv) pairwiseAlignment(pattern = asv, subject = mock_seqs[i], type = &#39;global-local&#39;))
    tibble(
      species = names(mock_seqs)[i],
      align_len = map_dbl(aligned, nchar),
      mismatch = map_dbl(aligned, align_mismatch),
      pid = (align_len - mismatch) / align_len,
      abund = locus_data$asv_count,
      asv_seq = locus_data$sequence, 
      ref_seq = mock_seqs[i],
      alignment = aligned
    )
  })
  aligned_data &lt;- bind_rows(aligned_data)

  aligned_data
}

filter_to_top_mc_ref_hits &lt;- function(aligned_data) {
  aligned_data %&gt;%
    group_by(species) %&gt;%
    slice_max(pid, n = 1) %&gt;%
    slice_max(abund, n = 1) %&gt;%
    arrange(desc(abund)) %&gt;%
    select(species, pid, mismatch, abund)
}</code></pre>
<p>For <strong>rps10</strong>:</p>
<pre class="r"><code>rps10_align_data &lt;- align_mock_comm_seqs(asv_data, &#39;rps10&#39;, rps10_ref_data)
as.data.frame(filter_to_top_mc_ref_hits(rps10_align_data))</code></pre>
<pre><code>##                       species       pid mismatch abund
## 1          Pythium apiculatum 1.0000000        0 45398
## 2   Phytophthora citrophthora 1.0000000        0 28991
## 3      Phytophthora kernoviae 1.0000000        0 22616
## 4       Phytophthora quercina 1.0000000        0 22213
## 5      Phytophthora hydrogena 1.0000000        0 21235
## 6        Phytophthora ramorum 1.0000000        0 16742
## 7         Saprolegnia diclina 1.0000000        0 10641
## 8            Pythium citrinum 1.0000000        0 10283
## 9         Plasmopara obducens 1.0000000        0  9428
## 10     Phytophthora infestans 1.0000000        0  8080
## 11      Phytophthora ipomoeae 1.0000000        0  8080
## 12     Phytophthora pluvialis 0.9977324        1  6415
## 13     Phytophthora cinnamomi 1.0000000        0  4745
## 14         Pythium irregulare 1.0000000        0  3967
## 15         Pythium oligandrum 1.0000000        0  3636
## 16    Phytophthora himalsilva 1.0000000        0  3605
## 17    Phytophthora rosacearum 1.0000000        0  2830
## 18      Aphanomyces euteiches 1.0000000        0  2572
## 19         Pythium dissotocum 1.0000000        0   938
## 20         Peronospora effusa 1.0000000        0   902
## 21      Peronospora schachtii 1.0000000        0   902
## 22 Pseudoperonospora cubensis 1.0000000        0   330
## 23          Pythium undulatum 0.9977273        1   128
## 24       Plasmopara halstedii 0.9977778        1    90</code></pre>
<p>For <strong>ITS1</strong>:</p>
<pre class="r"><code>its_align_data &lt;- align_mock_comm_seqs(asv_data, &#39;ITS&#39;, its_ref_data)
as.data.frame(filter_to_top_mc_ref_hits(its_align_data))</code></pre>
<pre><code>##                       species       pid mismatch  abund
## 1   Phytophthora citrophthora 1.0000000        0 147595
## 2     Phytophthora himalsilva 0.9955556        1 147595
## 3        Phytophthora ramorum 1.0000000        0  60788
## 4      Phytophthora hydrogena 1.0000000        0  47346
## 5       Phytopythium citrinum 0.9964286        1  30404
## 6      Phytophthora cinnamomi 1.0000000        0  25411
## 7       Phytophthora quercina 1.0000000        0  12611
## 8      Phytophthora kernoviae 1.0000000        0   9264
## 9         Saprolegnia diclina 1.0000000        0   4206
## 10         Pythium apiculatum 1.0000000        0   3192
## 11     Phytophthora infestans 1.0000000        0   2892
## 12      Phytophthora ipomoeae 1.0000000        0   2892
## 13    Phytophthora rosacearum 1.0000000        0   2550
## 14         Pythium oligandrum 1.0000000        0   2438
## 15         Pythium dissotocum 1.0000000        0   2143
## 16          Pythium undulatum 1.0000000        0   1929
## 17     Phytophthora pluvialis 1.0000000        0   1289
## 18         Pythium irregulare 0.9969419        1   1089
## 19        Plasmopara obducens 1.0000000        0   1016
## 20      Aphanomyces euteiches 1.0000000        0    525
## 21         Peronospora effusa 1.0000000        0    351
## 22      Peronospora schachtii 1.0000000        0    351
## 23       Plasmopara halstedii 1.0000000        0    114
## 24 Pseudoperonospora cubensis 1.0000000        0     58</code></pre>
<p>I will also save the alignments for all of the best matches:</p>
<pre class="r"><code>print_align &lt;- function(align) {
  ref &lt;- as.character(align@subject)
  asv &lt;- as.character(align@pattern)
  match_str &lt;- paste0(ifelse(iupac_match(strsplit(asv, split = &#39;&#39;)[[1]], strsplit(ref, split = &#39;&#39;)[[1]]), &#39;|&#39;, &#39; &#39;), collapse = &#39;&#39;)
  paste(
    sep = &#39;\n&#39;,
    paste(&#39;REF:&#39;, ref), 
    paste(&#39;    &#39;, match_str), 
    paste(&#39;ASV:&#39;, asv)
  )
}

save_best_mc_ref_alignments &lt;- function(aligned_data, path) {
  aligned_data &lt;- aligned_data %&gt;%
      group_by(species) %&gt;%
      slice_max(pid, n = 1) %&gt;%
      slice_max(abund, n = 1)
  align_str &lt;- map_chr(aligned_data$alignment, print_align)
  title &lt;- paste0(aligned_data$species, &#39; (PID:&#39;, aligned_data$pid, &#39; mismatch: &#39;, aligned_data$mismatch, &#39;  reads: &#39;, aligned_data$abund, &#39;)&#39;)
  write_lines(paste0(title, &#39;\n&#39;, align_str, &#39;\n&#39;, sep = &#39;\n&#39;, collapse = &#39;\n&#39;), file = path)
}

save_best_mc_ref_alignments(rps10_align_data, file.path(&#39;results&#39;, &#39;best_mc_ref_alignments_rps10.txt&#39;))
save_best_mc_ref_alignments(its_align_data, file.path(&#39;results&#39;, &#39;best_mc_ref_alignments_its1.txt&#39;))</code></pre>
<p>and add the number of expected mock community sequences we found for each locus:</p>
<pre class="r"><code>locus_result_table$n_mc_in_seq &lt;- c(sum(filter_to_top_mc_ref_hits(rps10_align_data)$mismatch == 0), 
                                    sum(filter_to_top_mc_ref_hits(its_align_data)$mismatch == 0))
locus_result_table$n_mc_in_seq_approx &lt;- c(sum(filter_to_top_mc_ref_hits(rps10_align_data)$mismatch &lt;= 1), 
                                           sum(filter_to_top_mc_ref_hits(its_align_data)$mismatch &lt;= 1))</code></pre>
</div>
<div id="the-proportion-of-asvs-matching-the-sequences-of-an-expected-member-of-the-mock-community" class="section level4">
<h4>The proportion of ASVs matching the sequences of an expected member of the mock community</h4>
<p>I will summarize the alignment data in the context of each ASV that best matched a reference sequence in the same way as above for the reference sequences First, I will print out the alignment statistics:</p>
<pre class="r"><code>filter_to_top_asv_hits &lt;- function(aligned_data) {
  aligned_data %&gt;%
    group_by(asv_seq) %&gt;%
    slice_max(pid, n = 1, with_ties = FALSE) %&gt;%
    arrange(desc(abund)) %&gt;%
    ungroup() %&gt;%
    select(species, pid, mismatch, abund)
}</code></pre>
<p>For <strong>rps10</strong>:</p>
<pre class="r"><code>as.data.frame(filter_to_top_asv_hits(rps10_align_data))</code></pre>
<pre><code>##                       species       pid mismatch abund
## 1          Pythium apiculatum 1.0000000        0 45398
## 2   Phytophthora citrophthora 1.0000000        0 28991
## 3      Phytophthora kernoviae 1.0000000        0 22616
## 4       Phytophthora quercina 1.0000000        0 22213
## 5      Phytophthora hydrogena 1.0000000        0 21235
## 6        Phytophthora ramorum 1.0000000        0 16742
## 7   Phytophthora citrophthora 1.0000000        0 12259
## 8         Saprolegnia diclina 1.0000000        0 10641
## 9            Pythium citrinum 1.0000000        0 10283
## 10        Plasmopara obducens 1.0000000        0  9428
## 11     Phytophthora infestans 1.0000000        0  8080
## 12     Phytophthora pluvialis 0.9977324        1  6415
## 13     Phytophthora cinnamomi 1.0000000        0  4745
## 14         Pythium irregulare 1.0000000        0  3967
## 15         Pythium oligandrum 1.0000000        0  3636
## 16    Phytophthora himalsilva 1.0000000        0  3605
## 17    Phytophthora rosacearum 1.0000000        0  2830
## 18      Aphanomyces euteiches 1.0000000        0  2572
## 19    Phytophthora himalsilva 1.0000000        0  1838
## 20         Pythium dissotocum 1.0000000        0   938
## 21         Peronospora effusa 1.0000000        0   902
## 22      Aphanomyces euteiches 0.9977679        1   872
## 23         Pythium apiculatum 0.9316629       30   516
## 24         Pythium apiculatum 0.9362187       28   478
## 25     Phytophthora kernoviae 0.9537037       20   351
## 26 Pseudoperonospora cubensis 1.0000000        0   330
## 27          Pythium undulatum 0.9977273        1   128
## 28     Phytophthora hydrogena 0.9477273       23   121
## 29       Plasmopara halstedii 0.9977778        1    90
## 30         Pythium apiculatum 0.9090909       40    83
## 31     Phytophthora hydrogena 0.9181818       36    45
## 32     Phytophthora infestans 0.9411765       26    43
## 33         Pythium apiculatum 0.9181818       36    31
## 34      Phytophthora quercina 0.9751131       11    29
## 35         Pythium dissotocum 0.9227273       34    24
## 36     Phytophthora cinnamomi 0.9705882       13    21
## 37         Pythium dissotocum 0.9204545       35    20
## 38         Pythium dissotocum 0.8866213       50    19
## 39        Saprolegnia diclina 0.8068182       85    18
## 40     Phytophthora pluvialis 0.9727891       12    12</code></pre>
<p>For <strong>ITS1</strong>:</p>
<pre class="r"><code>as.data.frame(filter_to_top_asv_hits(its_align_data))</code></pre>
<pre><code>##                       species       pid mismatch  abund
## 1   Phytophthora citrophthora 1.0000000        0 147595
## 2        Phytophthora ramorum 1.0000000        0  60788
## 3      Phytophthora hydrogena 1.0000000        0  47346
## 4       Phytopythium citrinum 0.9964286        1  30404
## 5      Phytophthora cinnamomi 1.0000000        0  25411
## 6       Phytophthora quercina 1.0000000        0  12611
## 7      Phytophthora kernoviae 1.0000000        0   9264
## 8         Saprolegnia diclina 1.0000000        0   4206
## 9      Phytophthora hydrogena 0.9951691        1   3438
## 10         Pythium apiculatum 1.0000000        0   3192
## 11     Phytophthora infestans 1.0000000        0   2892
## 12    Phytophthora rosacearum 1.0000000        0   2550
## 13         Pythium oligandrum 1.0000000        0   2438
## 14         Pythium dissotocum 1.0000000        0   2143
## 15          Pythium undulatum 1.0000000        0   1929
## 16     Phytophthora hydrogena 0.9951691        1   1626
## 17     Phytophthora pluvialis 1.0000000        0   1289
## 18         Pythium irregulare 0.9938838        2   1174
## 19         Pythium irregulare 0.9969419        1   1089
## 20        Plasmopara obducens 1.0000000        0   1016
## 21         Pythium apiculatum 0.9962121        1   1005
## 22          Pythium undulatum 0.9947090        1    836
## 23      Aphanomyces euteiches 1.0000000        0    525
## 24    Phytophthora rosacearum 0.9960938        1    495
## 25         Pythium irregulare 0.9816514        6    464
## 26         Pythium irregulare 0.9847095        5    451
## 27     Phytophthora hydrogena 0.9951691        1    448
## 28  Phytophthora citrophthora 0.9955556        1    394
## 29         Peronospora effusa 1.0000000        0    351
## 30         Pythium irregulare 0.9877676        4    325
## 31        Plasmopara obducens 1.0000000        0    317
## 32     Phytophthora infestans 0.9959839        1    295
## 33         Pythium apiculatum 0.9962121        1    295
## 34    Phytophthora rosacearum 0.9961089        1    170
## 35    Phytophthora himalsilva 0.9911111        2    135
## 36     Phytophthora hydrogena 0.9758454        5    122
## 37         Pythium apiculatum 0.9962121        1    115
## 38       Plasmopara halstedii 1.0000000        0    114
## 39     Phytophthora hydrogena 0.9806763        4     84
## 40         Pythium irregulare 0.9908257        3     62
## 41 Pseudoperonospora cubensis 1.0000000        0     58
## 42     Phytophthora pluvialis 0.6337209       63     40
## 43       Phytophthora ramorum 0.5760000      106     13
## 44        Plasmopara obducens 0.8700361       36     10
## 45  Phytophthora citrophthora 0.5523013      107     10</code></pre>
<p>I will also save the best alignments for each ASV:</p>
<pre class="r"><code>save_best_asv_alignments &lt;- function(aligned_data, path) {
  aligned_data &lt;- aligned_data %&gt;%
      group_by(asv_seq) %&gt;%
      slice_max(pid, n = 1, with_ties = FALSE) 
  align_str &lt;- map_chr(aligned_data$alignment, print_align)
  title &lt;- paste0(aligned_data$species, &#39; (PID:&#39;, aligned_data$pid, &#39; mismatch: &#39;, aligned_data$mismatch, &#39;  reads: &#39;, aligned_data$abund, &#39;)&#39;)
  write_lines(paste0(title, &#39;\n&#39;, align_str, &#39;\n&#39;, sep = &#39;\n&#39;, collapse = &#39;\n&#39;), path = path)
}

save_best_asv_alignments(rps10_align_data, file.path(&#39;results&#39;, &#39;best_asv_alignments_rps10.txt&#39;))</code></pre>
<pre><code>## Warning: The `path` argument of `write_lines()` is deprecated as of readr 1.4.0.
## Please use the `file` argument instead.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_warnings()` to see where this warning was generated.</code></pre>
<pre class="r"><code>save_best_asv_alignments(its_align_data, file.path(&#39;results&#39;, &#39;best_asv_alignments_its1.txt&#39;))</code></pre>
<p>I will add the proportion of ASVs that matched an expected reference sequence, allowing for a 1bp difference in the alignmnet:</p>
<pre class="r"><code>prop_seq_in_mc &lt;- function(aligned_data) {
  aligned_data &lt;- filter_to_top_asv_hits(aligned_data)
  sum(aligned_data$mismatch &lt;= 1) / nrow(aligned_data)
}

locus_result_table$prop_asv_in_mc_seq &lt;- c(prop_seq_in_mc(rps10_align_data), prop_seq_in_mc(its_align_data))</code></pre>
<p>and the proportion of reads represented by those sequences</p>
<pre class="r"><code>prop_reads_in_mc &lt;- function(aligned_data) {
  aligned_data &lt;- filter_to_top_asv_hits(aligned_data)
  sum(aligned_data$abund[aligned_data$mismatch &lt;= 1]) / sum(aligned_data$abund)
}

locus_result_table$prop_reads_in_mc_seq &lt;- c(prop_reads_in_mc(rps10_align_data), prop_reads_in_mc(its_align_data))</code></pre>
<p>Finally, I will save the table of summary statistics generated in the last few sections:</p>
<pre class="r"><code>num_col &lt;- map_lgl(locus_result_table, is.numeric)
locus_result_table[num_col] &lt;- lapply(locus_result_table[num_col], round, digits = 3)
write_csv(locus_result_table, file = file.path(&#39;results&#39;, &#39;mock_community_summary_statistics.csv&#39;))
print(locus_result_table)</code></pre>
<pre><code>## # A tibble: 2 x 10
##   locus n_asv n_otu n_mc_in_tax prop_asv_in_mc_… prop_reads_in_m… n_mc_in_seq
##   &lt;chr&gt; &lt;tab&gt; &lt;tab&gt;       &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt;
## 1 rps10 40    46             23            0.95             1              21
## 2 ITS   45    30             17            0.756            0.545          21
## # … with 3 more variables: n_mc_in_seq_approx &lt;dbl&gt;, prop_asv_in_mc_seq &lt;dbl&gt;,
## #   prop_reads_in_mc_seq &lt;dbl&gt;</code></pre>
</div>
</div>
<div id="plot-composition-of-the-mock-community" class="section level3">
<h3>Plot composition of the mock community</h3>
<p>I will make heat trees for each of the mock community samples with the taxa that are should not be there highlighted. Here is a function to calculated the data plotted for each sample:</p>
<pre class="r"><code>plot_comp &lt;- function(locus, title, path) {
  x &lt;- asv_data$clone(deep = TRUE)
  
  # Get right reference data for locus
  if (locus == &#39;rps10&#39;) {
    ref_data &lt;- rps10_ref_data
  } else if (locus == &#39;ITS&#39;) {
    ref_data &lt;- its_ref_data
  } else {
    stop(&#39;Invalid locus&#39;)
  }
  
  # Subset to only samples used in this plot
  x$data$prop &lt;- x$data$prop[x$data$prop$locus == locus, ]
  x$data$abund &lt;- x$data$abund[x$data$abund$locus == locus, ]
  x$data$score &lt;- x$data$score[x$data$score$sequence %in% x$data$abund$sequence, ]
  
  # Get per-taxon mean proportions and read counts
  x$data$tax_prop &lt;- calc_taxon_abund(x, &#39;prop&#39;, cols = &#39;asv_count&#39;, out_names = &#39;tax_prop&#39;)
  x$data$tax_abund &lt;- calc_taxon_abund(x, &#39;abund&#39;, cols = &#39;asv_count&#39;, out_names = &#39;tax_count&#39;)
  
  # Remove taxa and bootstrap scores for taxa/ASVs not in plot
  x &lt;- filter_taxa(x, tax_count &gt; minimum_read_count, reassign_obs = FALSE)
  
  # Get mean bootstrap score per taxon
  x$data$score$boot[x$data$score$rank == &#39;ASV&#39;] &lt;- NA
  x$data$tax_prop$mean_boot &lt;- obs_apply(x, &#39;score&#39;, value = &#39;boot&#39;, recursive = FALSE, func = function(boots) {
    mean(as.numeric(boots), na.rm = TRUE)
  }) %&gt;% unlist
  
  # Replace the bootstrap value for the ASVs with their PID to the reference
  x$data$abund$assigned_pid &lt;- as.numeric(str_match(x$data$abund$taxonomy, pattern = &#39;^.+--([0-9.]+)--ASV$&#39;)[,2]) / 100
  x$data$tax_prop$mean_boot[match(x$data$abund$taxon_id, x$data$tax_prop$taxon_id)] &lt;- x$data$abund$assigned_pid * 100
  
  # Find which taxa are part of mock community
  species_ids &lt;- map_chr(supertaxa(x, value = &#39;taxon_ids&#39;, recursive = 2), `[`, 2)[x$data$abund$taxon_id]
  species_found &lt;- gsub(taxon_names(x)[species_ids], pattern = &#39;_&#39;, replacement = &#39; &#39;)
  species_in_mc &lt;- tolower(species_found) %in% tolower(unlist(mc_data$all_names))
  x$data$taxa_in_mc &lt;- map_lgl(subtaxa(x, value = &#39;taxon_ids&#39;, include_input = TRUE), function(i) any(i %in% species_ids[species_in_mc]))
  
  # Plot
  x %&gt;% 
    filter_taxa(! is_stem) %&gt;%
    # filter_taxa(taxon_ranks != &#39;Reference&#39;) %&gt;%
    # remove_redundant_names() %&gt;%
    heat_tree(node_label = ifelse(taxon_ranks == &#39;ASV&#39;, 
                                  paste0(&#39;PID: &#39;, format(mean_boot, digits = 3, trim = TRUE), &#39;\nN: &#39;, tax_count),
                                  gsub(taxon_names, pattern = &#39;_&#39;, replacement = &#39; &#39;)),
              node_label_color = ifelse(taxa_in_mc | taxon_ranks %in% c(&#39;ASV&#39;, &#39;Reference&#39;), &#39;black&#39;, &#39;darkred&#39;),
              node_size = tax_prop, 
              node_size_range = c(0.005, 0.035),
              node_size_interval = c(0, 1),
              node_label_size_range = c(0.012, 0.025),
              node_size_axis_label = &#39;Mean read proportion&#39;,
              node_color = ifelse(taxon_ranks == &#39;ASV&#39;, &#39;grey&#39;, mean_boot),
              node_color_axis_label = &#39;Mean bootstrap&#39;,
              node_color_trans = &#39;linear&#39;,
              node_color_range = c(&#39;red&#39;, &#39;red&#39;, &#39;red&#39;, &#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;, &#39;yellow&#39;, &#39;green&#39;, &#39;lightblue&#39;),
              node_color_interval = c(0, 100),
              title = title,
              output_file = path)
}

sample_plots &lt;- lapply(c(&quot;rps10&quot;, &quot;ITS&quot;), function(locus) {
  mdat &lt;- metadata[metadata$locus == locus &amp; metadata$sample_id %in% mock_samples, ]
  mdat$primer_pair_id &lt;-  gsub(mdat$primer_pair_id, pattern = &#39;/&#39;, replacement = &#39;-&#39;, fixed = TRUE)
  my_plot &lt;- plot_comp(locus = locus, 
                       title = locus,
                       path = file.path(&#39;results&#39;, paste0(&#39;mock_comm_heat_tree_&#39;, mdat$primer_pair_id, &#39;.pdf&#39;)))
  print(my_plot)
  my_plot
})</code></pre>
<p><img src="06--mock_community_files/figure-html/unnamed-chunk-36-1.png" width="960" /><img src="06--mock_community_files/figure-html/unnamed-chunk-36-2.png" width="960" /></p>
</div>
</div>
<div id="phylogenetic-tree" class="section level2">
<h2>Phylogenetic tree</h2>
<pre class="r"><code>make_full_tree &lt;- function(locus, ref_data, path, title = locus, only_best_matches = FALSE, legend = TRUE) {
  
  # Subset data to just locus plotted
  asv_match_data &lt;- filter(asv_data$data$abund, locus == !! locus) 
  
  # Only consider the ASVs in each species with the best match to the reference
  if (only_best_matches) {
    asv_match_data &lt;- map(split(asv_match_data, asv_match_data$species), 
                          function(x) arrange(x, desc(assigned_pid), desc(asv_count))[1, ]) %&gt;%
      bind_rows()
  }
  
  # Get sequences of mock community members
  if (locus == &quot;rps10&quot;) {
    mock_seqs &lt;- read_fasta(file.path(&#39;raw_data&#39;, &#39;reference_databases&#39;, &#39;mock_comm_rps10_sanger.fasta&#39;))
    names(mock_seqs) &lt;- trimws(names(mock_seqs))
    names(mock_seqs) &lt;- gsub(names(mock_seqs), pattern = &#39;_&#39;, replacement = &#39; &#39;)
    names(mock_seqs) &lt;- str_match(names(mock_seqs), pattern = &#39;^.+;(.+)$&#39;)[, 2]
  } else if (locus == &quot;ITS&quot;) {
    mock_seqs &lt;- read_fasta(file.path(&#39;raw_data&#39;, &#39;reference_databases&#39;, &#39;mock_comm_its1_sanger.fasta&#39;))
    names(mock_seqs) &lt;- str_match(names(mock_seqs), pattern = &#39;^(.+) .+$&#39;)[, 2]
  } else {
    stop(&#39;Wrong locus type&#39;)
  }
  
 
  # Combine sequences
  seq_data &lt;- tibble(
    name = c(paste0(&#39;ASV (&#39;, asv_match_data$asv_count, &#39;)&#39;), names(mock_seqs)),
    type = rep(c(&#39;ASV&#39;, &#39;Reference&#39;), c(nrow(asv_match_data), length(mock_seqs))),
    sequence = c(asv_match_data$sequence, mock_seqs)
    )
  seq_data$sequence &lt;- trimws(toupper(seq_data$sequence))
  
  # Align sequences:
  aligned &lt;- seq_data$sequence %&gt;%
    setNames(1:nrow(seq_data)) %&gt;%
    char2dna() %&gt;%
    mafft(method = &#39;localpair&#39;, exec = &#39;mafft&#39;)
  
  # Make tree
  make_tree &lt;- function(aligned) {
    dist &lt;- dist.dna(aligned, model = &#39;N&#39;)
    tree &lt;- nj(dist)
    tree &lt;- ladderize(tree)
    tree &lt;- midpoint(tree)
    tree
  }
  tree &lt;- make_tree(aligned)
  boot &lt;- boot.phylo(tree, aligned, make_tree, quiet = TRUE)
  # boot[boot == 100] &lt;- NA
  
  # Plot tree
  # pdf(file = path, width = 7, height = 8)
  tree$tip.label &lt;- seq_data$name
  tree$node.label &lt;- boot
  plot.phylo(tree)
  title(main = title, adj = 0)
  nodelabels(ifelse(boot == 100, NA, boot), frame = &#39;none&#39;, cex = 0.61, adj = c(1.5, -.2))
  axis(side = 1)
  title(xlab = &#39;Number of differing sites&#39;)
  # dev.off()
  
  return(boot)
}


make_phylo_plot &lt;- function() {
  par(mfrow = c(1, 2))
  its1_phylo_boot &lt;- make_full_tree(locus = &#39;ITS&#39;,
                                    ref_data = its_ref_data,
                                    path = file.path(&#39;results&#39;, &#39;mock_comm_phylo_full_its1.pdf&#39;),
                                    title = &#39;A. ITS1&#39;,
                                    legend = TRUE)
  rps10_phylo_boot &lt;- make_full_tree(locus = &#39;rps10&#39;, 
                                     ref_data = rps10_ref_data, 
                                     path = file.path(&#39;results&#39;, &#39;mock_comm_phylo_full_rps10.pdf&#39;),
                                     title = &#39;B. RPS10&#39;,
                                     legend = FALSE)
  tibble(locus = rep(c(&#39;rps10&#39;, &#39;ITS&#39;), c(length(rps10_phylo_boot), length(its1_phylo_boot))),
         boot = c(rps10_phylo_boot, its1_phylo_boot),
         rank = &#39;Branch&#39;,
         type = &#39;Neighbor Joining&#39;)
  
}</code></pre>
<p>Plot and save the plot:</p>
<pre class="r"><code>pdf(file = file.path(&#39;results&#39;, &#39;mock_comm_phylo_full.pdf&#39;), width = 16, height = 16)
phylo_boot_data &lt;- make_phylo_plot()
dev.off()</code></pre>
<pre><code>## png 
##   2</code></pre>
<pre class="r"><code>phylo_boot_data &lt;- make_phylo_plot() </code></pre>
<p><img src="06--mock_community_files/figure-html/unnamed-chunk-38-1.png" width="1536" /></p>
<div id="bootstrap-analysis" class="section level3">
<h3>Bootstrap analysis</h3>
<p>In order to see how well the two barcodes can be used to assign taxonomy and resolve phylogenetic trees, I will compare the bootstrap values from dada2 and the neighbor-joining trees produced with ape.</p>
<pre class="r"><code>tax_boot_data &lt;- asv_data$data$score[asv_data$data$score$rank %in% c(&#39;Genus&#39;, &#39;Species&#39;, &#39;Reference&#39;), ]
# tax_boot_data &lt;- asv_data$data$score
tax_boot_data$locus &lt;- asv_data$data$abund$locus[match(tax_boot_data$sequence, asv_data$data$abund$sequence)]
tax_boot_data$type &lt;- &#39;Naive Bayesian Classifier&#39;
tax_boot_data$boot &lt;- as.integer(tax_boot_data$boot)
boot_data &lt;- bind_rows(phylo_boot_data, tax_boot_data[, colnames(phylo_boot_data)])
boot_data</code></pre>
<pre><code>## # A tibble: 385 x 4
##    locus  boot rank   type            
##    &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;           
##  1 rps10   100 Branch Neighbor Joining
##  2 rps10    19 Branch Neighbor Joining
##  3 rps10    10 Branch Neighbor Joining
##  4 rps10    28 Branch Neighbor Joining
##  5 rps10    17 Branch Neighbor Joining
##  6 rps10    25 Branch Neighbor Joining
##  7 rps10    39 Branch Neighbor Joining
##  8 rps10    37 Branch Neighbor Joining
##  9 rps10    25 Branch Neighbor Joining
## 10 rps10    60 Branch Neighbor Joining
## # … with 375 more rows</code></pre>
<p>Now I can graph it with histograms</p>
<pre class="r"><code>boot_plot &lt;- boot_data %&gt;%
  # filter(type == &#39;Taxonomic&#39;) %&gt;%
  mutate(rank = factor(rank, levels = rev(c(&#39;Branch&#39;, &#39;Genus&#39;, &#39;Species&#39;, &#39;Reference&#39;)), ordered = TRUE),
         locus = ordered(c(rps10 = &#39;rps10&#39;, ITS = &#39;ITS1&#39;)[locus], levels = c(&#39;rps10&#39;, &#39;ITS1&#39;))) %&gt;%
  ggplot(aes(x = rank, y = boot, fill = locus)) +
  facet_grid(. ~ type, scales = &#39;free&#39;, space = &#39;free_x&#39;) +
  geom_boxplot() +
  scale_fill_viridis_d(begin = 0.8, end = 0.2) +
  labs(x = &#39;&#39;, y = &#39;Bootstrap Score&#39;, fill = &#39;Locus&#39;) +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position=&quot;bottom&quot;) 
boot_plot</code></pre>
<pre><code>## Warning: Removed 1 rows containing non-finite values (stat_boxplot).</code></pre>
<p><img src="06--mock_community_files/figure-html/unnamed-chunk-40-1.png" width="480" /></p>
<pre class="r"><code>ggsave(boot_plot, filename = &#39;mock_comm_bootstrap.pdf&#39;, path = &#39;results&#39;, width = 7, height = 5)</code></pre>
<pre><code>## Warning: Removed 1 rows containing non-finite values (stat_boxplot).</code></pre>
<p><strong>Caption:</strong></p>
<p>Figure #: The distribution of bootstrap scores for the taxonomic assignment of ASVs in the mock community for the ITS1 and Rps10 loci. The RDP Naive Bayesian Classifier “Reference”, “Species”, and “Genus” scores refer the ability to consistently assign ASVs to a particular reference sequence, species, or genus respectively when the data is resampled. The neighbor joining tree scores quantify how consistent the branching pattern of the resulting tree is when the data is resampled.</p>
</div>
</div>
<div id="software-used" class="section level2">
<h2>Software used</h2>
<pre class="r"><code>sessioninfo::session_info()</code></pre>
<pre><code>## ─ Session info ───────────────────────────────────────────────────────────────
##  setting  value                       
##  version  R version 4.0.3 (2020-10-10)
##  os       Pop!_OS 20.04 LTS           
##  system   x86_64, linux-gnu           
##  ui       X11                         
##  language en_US:en                    
##  collate  en_US.UTF-8                 
##  ctype    en_US.UTF-8                 
##  tz       America/Vancouver           
##  date     2021-05-20                  
## 
## ─ Packages ───────────────────────────────────────────────────────────────────
##  package      * version    date       lib source        
##  ade4           1.7-16     2020-10-28 [1] CRAN (R 4.0.3)
##  ape          * 5.4-1      2020-08-13 [1] CRAN (R 4.0.2)
##  aphid          1.3.3      2019-05-08 [1] CRAN (R 4.0.3)
##  askpass        1.1        2019-01-13 [1] CRAN (R 4.0.2)
##  assertthat     0.2.1      2019-03-21 [1] CRAN (R 4.0.2)
##  BiocGenerics * 0.34.0     2020-04-27 [1] Bioconductor  
##  Biostrings   * 2.56.0     2020-04-27 [1] Bioconductor  
##  bold           1.1.0      2020-06-17 [1] CRAN (R 4.0.2)
##  cli            2.1.0      2020-10-12 [1] CRAN (R 4.0.3)
##  cluster        2.1.0      2019-06-19 [4] CRAN (R 4.0.0)
##  codetools      0.2-16     2018-12-24 [4] CRAN (R 4.0.0)
##  colorspace     1.4-1      2019-03-18 [1] CRAN (R 4.0.2)
##  conditionz     0.1.0      2019-04-24 [1] CRAN (R 4.0.2)
##  crayon         1.3.4      2017-09-16 [1] CRAN (R 4.0.2)
##  crosstalk      1.1.0.1    2020-03-13 [1] CRAN (R 4.0.2)
##  crul           1.0.0      2020-07-30 [1] CRAN (R 4.0.2)
##  curl           4.3        2019-12-02 [1] CRAN (R 4.0.2)
##  data.table     1.13.2     2020-10-19 [1] CRAN (R 4.0.3)
##  digest         0.6.27     2020-10-24 [1] CRAN (R 4.0.3)
##  dplyr        * 1.0.2      2020-08-18 [1] CRAN (R 4.0.2)
##  DT           * 0.16       2020-10-13 [1] CRAN (R 4.0.3)
##  ellipsis       0.3.1      2020-05-15 [1] CRAN (R 4.0.2)
##  evaluate       0.14       2019-05-28 [1] CRAN (R 4.0.2)
##  fansi          0.4.1      2020-01-08 [1] CRAN (R 4.0.2)
##  farver         2.0.3      2020-01-16 [1] CRAN (R 4.0.2)
##  fastmatch      1.1-0      2017-01-28 [1] CRAN (R 4.0.2)
##  foreach        1.5.1      2020-10-15 [1] CRAN (R 4.0.3)
##  furrr        * 0.2.1      2020-10-21 [1] CRAN (R 4.0.3)
##  future       * 1.19.1     2020-09-22 [1] CRAN (R 4.0.3)
##  generics       0.1.0      2020-10-31 [1] CRAN (R 4.0.3)
##  ggfittext      0.9.0      2020-06-14 [1] CRAN (R 4.0.2)
##  ggplot2      * 3.3.2      2020-06-19 [1] CRAN (R 4.0.2)
##  globals        0.13.1     2020-10-11 [1] CRAN (R 4.0.3)
##  glue           1.4.2      2020-08-27 [1] CRAN (R 4.0.2)
##  gridExtra    * 2.3        2017-09-09 [1] CRAN (R 4.0.3)
##  gtable         0.3.0      2019-03-25 [1] CRAN (R 4.0.2)
##  hms            0.5.3      2020-01-08 [1] CRAN (R 4.0.2)
##  htmltools      0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)
##  htmlwidgets    1.5.2      2020-10-03 [1] CRAN (R 4.0.3)
##  httpcode       0.3.0      2020-04-10 [1] CRAN (R 4.0.2)
##  igraph         1.2.6      2020-10-06 [1] CRAN (R 4.0.3)
##  insect       * 1.2.0      2018-11-25 [1] CRAN (R 4.0.3)
##  ips          * 0.0.11     2019-07-04 [1] CRAN (R 4.0.3)
##  IRanges      * 2.22.2     2020-05-21 [1] Bioconductor  
##  iterators      1.0.13     2020-10-15 [1] CRAN (R 4.0.3)
##  jsonlite       1.7.1      2020-09-07 [1] CRAN (R 4.0.2)
##  kmer           1.1.2      2019-05-20 [1] CRAN (R 4.0.3)
##  knitr          1.30       2020-09-22 [1] CRAN (R 4.0.2)
##  labeling       0.4.2      2020-10-20 [1] CRAN (R 4.0.3)
##  lattice      * 0.20-41    2020-04-02 [4] CRAN (R 4.0.0)
##  lazyeval       0.2.2      2019-03-15 [1] CRAN (R 4.0.2)
##  lifecycle      0.2.0      2020-03-06 [1] CRAN (R 4.0.2)
##  listenv        0.8.0      2019-12-05 [1] CRAN (R 4.0.3)
##  magrittr       1.5        2014-11-22 [1] CRAN (R 4.0.2)
##  MASS           7.3-53     2020-09-09 [4] CRAN (R 4.0.2)
##  Matrix         1.2-18     2019-11-27 [4] CRAN (R 4.0.0)
##  metacoder    * 0.3.4      2020-04-29 [1] CRAN (R 4.0.3)
##  mgcv           1.8-33     2020-08-27 [4] CRAN (R 4.0.2)
##  munsell        0.5.0      2018-06-12 [1] CRAN (R 4.0.2)
##  nlme           3.1-149    2020-08-23 [4] CRAN (R 4.0.2)
##  openssl        1.4.3      2020-09-18 [1] CRAN (R 4.0.2)
##  permute      * 0.9-5      2019-03-12 [1] CRAN (R 4.0.2)
##  phangorn     * 2.5.5      2019-06-19 [1] CRAN (R 4.0.2)
##  phylogram      2.1.0      2018-06-25 [1] CRAN (R 4.0.3)
##  pillar         1.4.6      2020-07-10 [1] CRAN (R 4.0.2)
##  pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.0.2)
##  plyr           1.8.6      2020-03-03 [1] CRAN (R 4.0.2)
##  prettyunits    1.1.1      2020-01-24 [1] CRAN (R 4.0.2)
##  progress       1.2.2      2019-05-16 [1] CRAN (R 4.0.2)
##  purrr        * 0.3.4      2020-04-17 [1] CRAN (R 4.0.2)
##  quadprog       1.5-8      2019-11-20 [1] CRAN (R 4.0.2)
##  R6             2.5.0      2020-10-28 [1] CRAN (R 4.0.3)
##  RANN           2.6.1      2019-01-08 [1] CRAN (R 4.0.3)
##  Rcpp           1.0.5      2020-07-06 [1] CRAN (R 4.0.2)
##  readr        * 1.4.0      2020-10-05 [1] CRAN (R 4.0.3)
##  reshape        0.8.8      2018-10-23 [1] CRAN (R 4.0.2)
##  reshape2       1.4.4      2020-04-09 [1] CRAN (R 4.0.2)
##  rlang          0.4.10     2020-12-30 [1] CRAN (R 4.0.3)
##  rmarkdown      2.5        2020-10-21 [1] CRAN (R 4.0.3)
##  rstudioapi     0.11       2020-02-07 [1] CRAN (R 4.0.2)
##  S4Vectors    * 0.26.1     2020-05-16 [1] Bioconductor  
##  scales         1.1.1      2020-05-11 [1] CRAN (R 4.0.2)
##  seqinr         4.2-4      2020-10-10 [1] CRAN (R 4.0.3)
##  sessioninfo  * 1.1.1      2018-11-05 [1] CRAN (R 4.0.2)
##  sharedbib      0.1.0.9003 2020-10-16 [1] local         
##  stringi        1.5.3      2020-09-09 [1] CRAN (R 4.0.2)
##  stringr      * 1.4.0      2019-02-10 [1] CRAN (R 4.0.2)
##  taxa         * 0.3.4      2020-04-29 [1] CRAN (R 4.0.3)
##  taxize       * 0.9.99     2020-10-30 [1] CRAN (R 4.0.3)
##  tibble         3.0.4      2020-10-12 [1] CRAN (R 4.0.3)
##  tidyr        * 1.1.2      2020-08-27 [1] CRAN (R 4.0.2)
##  tidyselect     1.1.0      2020-05-11 [1] CRAN (R 4.0.2)
##  utf8           1.1.4      2018-05-24 [1] CRAN (R 4.0.2)
##  uuid           0.1-4      2020-02-26 [1] CRAN (R 4.0.2)
##  vctrs          0.3.4      2020-08-29 [1] CRAN (R 4.0.2)
##  vegan        * 2.5-6      2019-09-01 [1] CRAN (R 4.0.2)
##  viridis      * 0.5.1      2018-03-29 [1] CRAN (R 4.0.3)
##  viridisLite  * 0.3.0      2018-02-01 [1] CRAN (R 4.0.2)
##  withr          2.3.0      2020-09-22 [1] CRAN (R 4.0.3)
##  xfun           0.19       2020-10-30 [1] CRAN (R 4.0.3)
##  XML            3.99-0.5   2020-07-23 [1] CRAN (R 4.0.2)
##  xml2           1.3.2      2020-04-23 [1] CRAN (R 4.0.2)
##  XVector      * 0.28.0     2020-04-27 [1] Bioconductor  
##  yaml           2.2.1      2020-02-01 [1] CRAN (R 4.0.2)
##  zlibbioc       1.34.0     2020-04-27 [1] Bioconductor  
##  zoo            1.8-8      2020-05-02 [1] CRAN (R 4.0.2)
## 
## [1] /home/fosterz/R/x86_64-pc-linux-gnu-library/4.0
## [2] /usr/local/lib/R/site-library
## [3] /usr/lib/R/site-library
## [4] /usr/lib/R/library</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
